<script>
  AOS.init({ duration: 900, easing: 'ease-out-cubic', offset: 120, once: true });

  function updateClock() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, "0");
    const mins = String(now.getMinutes()).padStart(2, "0");
    document.getElementById("clock").textContent = `${hours}:${mins}`;
    const options = { weekday: "long", day: "numeric", month: "short", year: "numeric" };
    document.getElementById("date-line").textContent = now.toLocaleDateString(undefined, options);
  }
  updateClock();
  setInterval(updateClock, 1000);

  const ISA_BACKEND_BASE = "https://isa-backend-olj9.onrender.com/api";
  const ISA_AI_ENDPOINT = `${ISA_BACKEND_BASE}/ask/`;
  const ISA_METAR_ENDPOINT = `${ISA_BACKEND_BASE}/metar`;

  async function askISA() {
    const input = document.getElementById("ai-query");
    const statusEl = document.getElementById("ai-status");
    const answerEl = document.getElementById("ai-answer");
    const question = (input.value || "").trim();
    if (!question) return;

    statusEl.textContent = "Thinking...";
    answerEl.classList.add("hidden");
    answerEl.classList.remove("show");

    try {
      const resp = await fetch(ISA_AI_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ question })
      });

      const text = await resp.text();
      let data = null;
      try { data = JSON.parse(text); } catch {}

      if (!resp.ok) {
        const detail = data?.detail || text || `HTTP ${resp.status}`;
        throw new Error(`AI error (${resp.status}): ${detail}`);
      }

      answerEl.textContent = data?.answer || "No answer returned.";
    } catch (err) {
      console.error(err);
      answerEl.textContent = String(err.message || err);
    } finally {
      statusEl.textContent = "";
      answerEl.classList.remove("hidden");
      requestAnimationFrame(() => answerEl.classList.add("show"));
    }
  }

  // ===== METAR UI helpers =====
  function pillClassFor(rating) {
    const r = (rating || "").toLowerCase();
    if (r.includes("excellent") || r.includes("good")) return "metar-pill good";
    if (r.includes("challenging") || r.includes("no report")) return "metar-pill warn";
    if (r.includes("poor") || r.includes("bad") || r.includes("error") || r.includes("timeout")) return "metar-pill bad";
    return "metar-pill";
  }

  function formatLocalTime(isoUtc) {
    if (!isoUtc) return { local: "—", utc: "—" };
    const d = new Date(isoUtc);
    if (isNaN(d.getTime())) return { local: "—", utc: isoUtc };
    return {
      local: d.toLocaleString([], {
        weekday: "short",
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
        timeZoneName: "short",
      }),
      utc: `UTC ${d.toISOString().slice(11, 16)}Z`,
    };
  }

  function ageFromIso(isoUtc) {
    if (!isoUtc) return "—";
    const d = new Date(isoUtc);
    const now = new Date();
    const mins = Math.round((now - d) / 60000);
    if (!isFinite(mins)) return "—";
    if (mins < 1) return "Just now";
    if (mins < 60) return `${mins} min ago`;
    const hrs = Math.floor(mins / 60);
    const rem = mins % 60;
    return `${hrs}h ${rem}m ago`;
  }

  function extractICAO(text) {
    if (!text) return null;
    // Prefer 4-letter ICAO, but allow 3-4 if user types short codes
    const t = text.toUpperCase();
    const m4 = t.match(/\b[A-Z0-9]{4}\b/);
    if (m4) return m4[0];
    const m3 = t.match(/\b[A-Z0-9]{3}\b/);
    return m3 ? m3[0] : null;
  }

  // ===== METAR fetch with better timeout handling =====
  let METAR_REQ_SEQ = 0;
  let metarAbort = null;
  let firstMetarFetch = true;

  async function fetchMetar(icaoRaw) {
    const icao = String(icaoRaw || "").trim().toUpperCase();
    if (!icao) return;

    const seq = ++METAR_REQ_SEQ;
    if (metarAbort) metarAbort.abort();
    metarAbort = new AbortController();

    const rawEl = document.getElementById("metar-raw");
    const ageEl = document.getElementById("metar-age");
    const ratingEl = document.getElementById("metar-rating");

    const mAirport = document.getElementById("m-airport");
    const mObsLocal = document.getElementById("m-obs-local");
    const mObsUtc = document.getElementById("m-obs-utc");
    const mSky = document.getElementById("m-sky");
    const mVis = document.getElementById("m-vis");
    const mWind = document.getElementById("m-wind");
    const mWindSub = document.getElementById("m-wind-sub");
    const mTemp = document.getElementById("m-temp");
    const mHumidity = document.getElementById("m-humidity");
    const mPressure = document.getElementById("m-pressure");

    rawEl.textContent = firstMetarFetch
      ? `Fetching METAR for ${icao}… (server may be waking up)`
      : `Fetching METAR for ${icao}…`;

    ageEl.textContent = "—";
    ratingEl.textContent = "Loading…";
    ratingEl.className = "metar-pill warn";

    mAirport.textContent = icao;
    mObsLocal.textContent = "—";
    mObsUtc.textContent = "—";
    mSky.textContent = "—";
    mVis.textContent = "—";
    mWind.textContent = "—";
    mWindSub.textContent = "—";
    mTemp.textContent = "—";
    mHumidity.textContent = "—";
    mPressure.textContent = "—";

    const timeoutMs = firstMetarFetch ? 30000 : 18000; // cold start-safe
    const timeout = setTimeout(() => metarAbort?.abort(), timeoutMs);

    try {
      const url = `${ISA_METAR_ENDPOINT}/${encodeURIComponent(icao)}?t=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store", signal: metarAbort.signal });
      if (seq !== METAR_REQ_SEQ) return;

      if (res.status === 204) {
        rawEl.textContent = "No recent METAR found.";
        ratingEl.textContent = "No report";
        ratingEl.className = pillClassFor("no report");
        firstMetarFetch = false;
        return;
      }

      const text = await res.text();
      if (seq !== METAR_REQ_SEQ) return;

      let data = null;
      if (text) { try { data = JSON.parse(text); } catch {} }

      if (!res.ok) {
        const detail = data?.detail || text || `HTTP ${res.status}`;
        throw new Error(detail);
      }

      if (!data || !data.raw_text) {
        rawEl.textContent = data?.detail || "No recent METAR found.";
        ratingEl.textContent = "No report";
        ratingEl.className = pillClassFor("no report");
        firstMetarFetch = false;
        return;
      }

      rawEl.textContent = data.raw_text;

      const obsUtc = data.obs_time_utc || data.plain_english?.observed_utc || null;
      const tLocal = formatLocalTime(obsUtc);
      mObsLocal.textContent = tLocal.local;
      mObsUtc.textContent = tLocal.utc;
      ageEl.textContent = ageFromIso(obsUtc);

      const rating = data.flight_conditions || data.plain_english?.flight_conditions || "Unknown";
      ratingEl.textContent = rating;
      ratingEl.className = pillClassFor(rating);

      mSky.textContent = data.sky || data.plain_english?.sky || "—";

      const vis = (data.visibility_mi ?? data.plain_english?.visibility_mi);
      mVis.textContent = (vis == null) ? "—" : `${vis} mi`;

      const wdir = (data.wind_dir_deg ?? data.plain_english?.wind?.dir_deg);
      const wspd = (data.wind_speed_kt ?? data.plain_english?.wind?.speed_kt);
      const wgst = (data.wind_gust_kt ?? data.plain_english?.wind?.gust_kt);

      if (wspd == null) {
        mWind.textContent = "—";
        mWindSub.textContent = "—";
      } else {
        const dirTxt = (wdir == null) ? "VRB" : `${wdir}°`;
        mWind.textContent = `${dirTxt} / ${wspd} kt`;
        mWindSub.textContent = wgst ? `Gusts ${wgst} kt` : "No gusts";
      }

      const tc = (data.temp_c ?? data.plain_english?.temperature_c);
      const dc = (data.dewpoint_c ?? data.plain_english?.dewpoint_c);
      const rh = (data.humidity_est_pct ?? data.plain_english?.humidity_est_pct);

      mTemp.textContent = (tc == null) ? "—" : `${tc} °C`;
      mHumidity.textContent = (dc == null || rh == null) ? "—" : `Dew ${dc}°C • RH ~${rh}%`;

      const p = (data.altimeter_inhg ?? data.plain_english?.pressure_inhg);
      mPressure.textContent = (p == null) ? "—" : `${p} inHg`;

      firstMetarFetch = false;

    } catch (e) {
      if (seq !== METAR_REQ_SEQ) return;
      if (e?.name === "AbortError") {
        rawEl.textContent = `Timed out fetching METAR for ${icao}. (If this is the first load, Render may still be waking up.)`;
        ratingEl.textContent = "Timeout";
        ratingEl.className = "metar-pill bad";
        return;
      }
      console.error(e);
      rawEl.textContent = `Error fetching METAR: ${e.message || e}`;
      ratingEl.textContent = "Error";
      ratingEl.className = "metar-pill bad";
    } finally {
      clearTimeout(timeout);
    }
  }

  // ===== Airport search UI (now aborts previous searches) =====
  let selectedAirport = null;

  const searchEl = document.getElementById("airport-search");
  const ddEl = document.getElementById("airport-dd");
  const distEl = document.getElementById("airport-distance");
  const geoBtn = document.getElementById("geo-btn");

  function showDropdown(on) {
    ddEl.classList.toggle("show", !!on);
  }

  function setSelectedAirport(a) {
    selectedAirport = a;
    const label = a?.label || a?.icao || "—";
    searchEl.value = label;
    distEl.textContent = `Selected: ${label}`;
    showDropdown(false);

    const icao = a?.icao || extractICAO(label);
    if (icao) fetchMetar(icao);
  }

  function renderDropdown(results) {
    ddEl.innerHTML = "";
    if (!results || results.length === 0) {
      const div = document.createElement("div");
      div.className = "airport-dd-empty";
      div.textContent = `No matches. Try ICAO (KJFK) or city/name.`;
      ddEl.appendChild(div);
      showDropdown(true);
      return;
    }

    results.forEach((r) => {
      const item = document.createElement("div");
      item.className = "airport-dd-item";
      item.innerHTML = `${r.label}<small>${(r.icao || "")}${r.iata ? " • " + r.iata : ""}</small>`;
      item.addEventListener("mousedown", (e) => {
        e.preventDefault();
        setSelectedAirport(r);
      });
      ddEl.appendChild(item);
    });

    showDropdown(true);
  }

  let searchTimer = null;
  let searchAbort = null;

  async function doAirportSearch(q) {
    q = (q || "").trim();
    if (!q || q.length < 2) { showDropdown(false); return; }

    if (searchAbort) searchAbort.abort();
    searchAbort = new AbortController();

    try {
      const url = `${ISA_METAR_ENDPOINT}/search?q=${encodeURIComponent(q)}&limit=10&t=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store", signal: searchAbort.signal });
      const data = await res.json();
      renderDropdown(data?.results || []);
    } catch (e) {
      if (e?.name === "AbortError") return;
      console.error(e);
      ddEl.innerHTML = `<div class="airport-dd-empty">Search error. Try again.</div>`;
      showDropdown(true);
    }
  }

  function debounceSearch(q) {
    if (searchTimer) clearTimeout(searchTimer);
    searchTimer = setTimeout(() => doAirportSearch(q), 180);
  }

  searchEl.addEventListener("focus", () => searchEl.select());

  searchEl.addEventListener("input", () => {
    const v = searchEl.value;
    // If the user is typing, assume they want search suggestions
    selectedAirport = null;
    debounceSearch(v);
  });

  searchEl.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      showDropdown(false);
      return;
    }

    if (e.key === "Enter") {
      e.preventDefault();
      const raw = searchEl.value.trim();
      const icao = extractICAO(raw);
      if (icao) {
        setSelectedAirport({ icao, label: raw });
        showDropdown(false);
        return;
      }

      const first = ddEl.querySelector(".airport-dd-item");
      if (first) first.dispatchEvent(new MouseEvent("mousedown"));
    }
  });

  document.addEventListener("click", (e) => {
    if (!ddEl.contains(e.target) && e.target !== searchEl) showDropdown(false);
  });

  // ===== Use my location -> backend nearest airport worldwide =====
  geoBtn.addEventListener("click", () => {
    if (!navigator.geolocation) {
      alert("Geolocation not supported by this browser.");
      return;
    }

    navigator.geolocation.getCurrentPosition(async (pos) => {
      const { latitude, longitude } = pos.coords;

      try {
        const url = `${ISA_METAR_ENDPOINT}/nearest?lat=${encodeURIComponent(latitude)}&lon=${encodeURIComponent(longitude)}&limit=1&t=${Date.now()}`;
        const res = await fetch(url, { cache: "no-store" });
        const data = await res.json();
        const best = data?.results?.[0];
        if (!best) throw new Error("No nearest airport returned.");

        const label = best.label + (best.distance_km != null ? ` (${best.distance_km.toFixed(1)} km)` : "");
        distEl.textContent = `Nearest: ${label}`;
        setSelectedAirport(best);
      } catch (e) {
        console.error(e);
        alert("Could not find nearest airport. Try searching manually.");
      }
    }, (err) => {
      console.error(err);
      alert("Could not get location. Check browser permissions.");
    });
  });

  // ===== Surface weather + winds aloft (your existing code stays the same) =====
  let ISA_LAT = 33.8177;
  let ISA_LON = -118.1516;

  function altitudeToPressureLevel(altFt) {
    if (altFt <= 5000) return 850;
    if (altFt <= 12000) return 700;
    if (altFt <= 18000) return 600;
    if (altFt <= 24000) return 500;
    if (altFt <= 30000) return 400;
    if (altFt <= 36000) return 300;
    return 250;
  }

  async function fetchSurfaceWeather(lat, lon) {
    const url =
      "https://api.open-meteo.com/v1/forecast?" +
      `latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}` +
      "&current=temperature_2m,relative_humidity_2m,pressure_msl,wind_speed_10m,wind_direction_10m" +
      "&hourly=temperature_2m,wind_speed_10m,wind_direction_10m" +
      "&forecast_days=1&timezone=auto";

    const res = await fetch(url);
    if (!res.ok) throw new Error("Open-Meteo weather fetch failed");
    const data = await res.json();

    const t = data.current.temperature_2m;
    const rh = data.current.relative_humidity_2m;
    const p = data.current.pressure_msl;
    const ws = data.current.wind_speed_10m;
    const wd = data.current.wind_direction_10m;

    const wsKt = (ws * 0.539957).toFixed(0);

    document.getElementById("wx-conditions").textContent = `${t.toFixed(0)}°C`;
    document.getElementById("wx-sub").textContent = `Humidity ${rh}%`;
    document.getElementById("wx-wind").textContent = `${wd.toFixed(0)}° / ${wsKt} kt`;
    document.getElementById("wx-pressure").textContent = `${p.toFixed(0)} hPa`;

    for (let i = 1; i <= 4; i++) {
      const time = data.hourly.time[i];
      const hhmm = new Date(time).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      const ht = data.hourly.temperature_2m[i];
      const hws = data.hourly.wind_speed_10m[i];
      const hwd = data.hourly.wind_direction_10m[i];
      const hwsKt = (hws * 0.539957).toFixed(0);

      document.getElementById(`fh-${i}t`).textContent = hhmm;
      document.getElementById(`fh-${i}w`).textContent = `${ht.toFixed(0)}°C`;
      document.getElementById(`fh-${i}s`).textContent = `${hwd.toFixed(0)}° ${hwsKt} kt`;
    }
  }

  async function fetchWindsAloft(lat, lon, altFt) {
    const level = altitudeToPressureLevel(altFt);
    const url =
      "https://api.open-meteo.com/v1/forecast?" +
      `latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}` +
      `&hourly=windspeed_${level}hPa,winddirection_${level}hPa` +
      "&forecast_days=1&timezone=auto";

    const res = await fetch(url);
    if (!res.ok) throw new Error("Open-Meteo winds aloft fetch failed");
    const data = await res.json();

    const ws = data.hourly[`windspeed_${level}hPa`][0];
    const wd = data.hourly[`winddirection_${level}hPa`][0];
    const wsKt = (ws * 0.539957).toFixed(0);

    document.getElementById("winds-aloft").textContent = `${wd.toFixed(0)}° / ${wsKt} kt`;
    document.getElementById("winds-aloft-sub").textContent = `${level} hPa level`;
  }

  function refreshWXandWinds() {
    const alt = parseInt(document.getElementById("alt-ft").value, 10);
    document.getElementById("alt-ft-label").textContent = alt.toLocaleString();
    fetchSurfaceWeather(ISA_LAT, ISA_LON).catch(console.error);
    fetchWindsAloft(ISA_LAT, ISA_LON, alt).catch(console.error);
  }

  document.addEventListener("DOMContentLoaded", () => {
    refreshWXandWinds();

    const slider = document.getElementById("alt-ft");
    slider.addEventListener("input", () => {
      document.getElementById("alt-ft-label").textContent = parseInt(slider.value,10).toLocaleString();
    });
    slider.addEventListener("change", refreshWXandWinds);

    setInterval(() => {
      if (selectedAirport?.icao) fetchMetar(selectedAirport.icao);
    }, 5 * 60 * 1000);

    setInterval(refreshWXandWinds, 10 * 60 * 1000);

    // default load
    setSelectedAirport({ icao: "KLGB", label: "KLGB (LGB) — Long Beach Airport · US" });
  });
</script>
